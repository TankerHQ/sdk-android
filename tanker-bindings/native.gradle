import javax.inject.Inject
import com.sun.jna.Platform

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'javax.inject:javax.inject:1'
        classpath 'net.java.dev.jna:jna-platform:4.5.1'
    }
}

class NativeHelper {
    static def conanAndroidArchs = ["x86_64": "x86_64", "x86": "x86", "armeabi-v7a":"armv7", "arm64-v8a": "armv8"]

    static def runCmd(cmd, path) {
        print("${path}: ${cmd} \n")
        def proc = cmd.execute(null, path)
        proc.consumeProcessOutput(System.out, System.err)
        proc.waitFor()
        if (proc.exitValue() != 0)
            throw new Exception("Command failed: ${cmd}")
    }

    static def getAndroidProfile(arch, buildType) {
        return "android-$arch-${buildType.toLowerCase()}"
    }

    // This creates a .jar with our .so inside, so we can put it in the classpath for tests
    static def createNativeLibJar(ArrayList prefixLibs, File installPath, String jarName) {
        runCmd("jar cf ${jarName} -C ${installPath} ${prefixLibs.join(" ")}", installPath)
    }

    static def copyTankerLibs(File sourceLibPath, ArrayList libNames, File installLibPath) {
        def libFilePaths = libNames.collect { new File(sourceLibPath, System.mapLibraryName(it)) }
        for (libFilePath in libFilePaths) {
          def prefixedLibPath = new File(installLibPath, libFilePath.name)
          prefixedLibPath.parentFile.mkdirs()
          prefixedLibPath.bytes = libFilePath.bytes // This is just a file copy in Groovy
        }
    }

    static def getTankerDepInfos(File conanOutputPath) {
        def conanJsonFile = new File(conanOutputPath, 'conanbuildinfo.json')
        def conanJson = new groovy.json.JsonSlurper().parseText(conanJsonFile.text)
        return conanJson.dependencies.find {it.name == 'tanker' }
    }
}

class Builder extends DefaultTask {
    final File projectPath
    final File conanPath
    final String buildType
    final File installPathBase

    Builder(String buildType) {
        this.projectPath = new File(getProject().getProjectDir().absolutePath)
        this.conanPath = new File(this.projectPath, "conan")
        this.buildType = buildType.toLowerCase()
        this.installPathBase = new File(this.projectPath, "src/${this.buildType}/jniLibs")
    }

    void compileForAndroid() {
        // Run each known android arch
        NativeHelper.conanAndroidArchs.each { k, v ->
            def conanOutPath = new File(this.conanPath, NativeHelper.getAndroidProfile(v, this.buildType))
            def installPath = new File(this.installPathBase, k)
            def tankerDepInfos = NativeHelper.getTankerDepInfos(conanOutPath)
            NativeHelper.copyTankerLibs(new File(tankerDepInfos.lib_paths.first()), tankerDepInfos.libs, installPath)
        }
    }

    void compileForHost() {
        def conanOutputPath = new File(this.conanPath, "linux-${this.buildType}-shared")
        def conanHostPath = new File(this.conanPath, 'host')
        conanHostPath.mkdirs()
        def tankerDepInfos = NativeHelper.getTankerDepInfos(conanOutputPath)
        def libNames = tankerDepInfos.libs
        def platformPrefix = Platform.getNativeLibraryResourcePrefix()
        NativeHelper.copyTankerLibs(new File(tankerDepInfos.lib_paths.first()), libNames, new File(conanHostPath, platformPrefix))
        NativeHelper.createNativeLibJar(libNames.collect { new File(platformPrefix, System.mapLibraryName(it)) }, conanHostPath, 'tanker-native.jar')
    }
}

class BuildNative extends Builder {
    final String buildFor

    @Inject BuildNative(String buildType, String buildFor) {
        super(buildType) 
        this.buildFor = buildFor
    }

    @TaskAction
    void compile() {
        if (buildFor == 'host' || buildFor == 'all')
            this.compileForHost()
        if (buildFor == 'android' || buildFor == 'all')
            this.compileForAndroid()
    }
}

task buildNativeHostDebug(type: BuildNative, constructorArgs: ['Debug', 'host'])
task buildNativeHostRelease(type: BuildNative, constructorArgs: ['Release', 'host'])
task buildNativeAndroidRelease(type: BuildNative, constructorArgs: ['Release', 'android'])
task buildNativeRelease(type: BuildNative, constructorArgs: ['Release', 'all'])

clean {
    delete "conan/build"
}
