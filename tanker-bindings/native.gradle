import javax.inject.Inject
import com.sun.jna.Platform

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'javax.inject:javax.inject:1'
        classpath 'net.java.dev.jna:jna-platform:4.5.1'
    }
}

class NativeHelper {
    static def conanAndroidArchs = ["x86_64": "x86_64", "x86": "x86", "armeabi-v7a":"armv7", "arm64-v8a": "armv8"]

    static def runCmd(cmd, path) {
        print("${path}: ${cmd} \n")
        def proc = cmd.execute(null, path)
        proc.consumeProcessOutput(System.out, System.err)
        proc.waitFor()
        if (proc.exitValue() != 0)
            throw new Exception("Command failed: ${cmd}")
    }

    static def getAndroidProfile(arch, buildType) {
        return "android-$arch-${buildType.toLowerCase()}"
    }

    static def getNativeProfile(buildType) {
        return "gcc8-${buildType.toLowerCase()}"
    }

    static def conanInstall(tankerConanRef, installPath, profile) {
        installPath.mkdirs()
        runCmd("conan install $tankerConanRef " +
                "--profile $profile " +
                "--options tanker:tankerlib_shared=True " +
                "--install-folder=$installPath ", installPath)
    }
    // This creates a .jar with our .so inside, so we can put it in the classpath for tests
    static def createNativeLibJar(File installPath, ArrayList libNames, String jarName) {
        def libPaths = libNames.collect { new File(installPath, it) }
        def platformPrefix = Platform.getNativeLibraryResourcePrefix()
        def prefixList = []
        for (libPath in libPaths) {
          def relPrefixedPath = platformPrefix + '/' + libPath.name
          prefixList << relPrefixedPath
          def prefixedLibPath = new File(libPath.parent + '/' + relPrefixedPath)
          prefixedLibPath.parentFile.mkdirs()
          prefixedLibPath.bytes = libPath.bytes // This is just a file copy in Groovy
        }
        runCmd("jar cf ${jarName} -C ${installPath} ${prefixList.join(" ")}", installPath)
    }
}

class Builder extends DefaultTask {
    final File projectPath
    final File conanPath
    final String buildType
    final File installPathBase
    final File conanOutputPath

    Builder(String buildType) {
        this.projectPath = new File(getProject().getProjectDir().absolutePath)
        this.conanPath = new File(this.projectPath, "conan")
        this.buildType = buildType.toLowerCase()
        this.installPathBase = new File(this.projectPath, "src/${this.buildType}/jniLibs")
        this.conanOutputPath = new File(this.conanPath, "host")
    }

    void compileForAndroid(String tankerConanRef) {
        // Run each known android arch
        NativeHelper.conanAndroidArchs.each { k, v ->
            def profile = NativeHelper.getAndroidProfile(v, this.buildType)
            def installPath = new File(this.installPathBase, k)
            NativeHelper.conanInstall(tankerConanRef, installPath, profile)
        }
    }

    void compileForHost(String tankerConanRef) {
        def installPath = this.conanOutputPath
        NativeHelper.conanInstall(tankerConanRef, installPath, NativeHelper.getNativeProfile(this.buildType))
        NativeHelper.createNativeLibJar(installPath, ["libctanker.so", "libtanker_admin-c.so"], 'tanker-native.jar')
    }
}

class BuildNative extends Builder {
    final String buildFor

    @Inject BuildNative(String buildType, String buildFor) {
        super(buildType) 
        this.buildFor = buildFor
    }

    @TaskAction
    void compile() {
        def tankerConanRef = new File(this.conanPath, "conanfile-local.txt")
        def tankerConanRefWithFlags = tankerConanRef.toString() + " --update --build=tanker"
        if (buildFor == 'android' || buildFor == 'all')
            this.compileForAndroid(tankerConanRefWithFlags)
        if (buildFor == 'host' || buildFor == 'all')
            this.compileForHost(tankerConanRefWithFlags)
    }
}

class UseDeployedNative extends Builder {

    @Inject UseDeployedNative(String buildType) {
        super(buildType)
    }

    @TaskAction
    void compile() {
        def tankerConanRef = new File(this.conanPath, "conanfile-deployed.txt")
        this.compileForAndroid(tankerConanRef.toString())
        this.compileForHost(tankerConanRef.toString())
    }
}

// If we didn't already fetch or build Native libs, we need to build them now
class RequireNativeLibs extends DefaultTask {
    @Inject RequireNativeLibs(String buildType, String buildFor) {
        boolean hasNativeLibs = true
        String projectPath = getProject().getProjectDir().absolutePath
        def installPathBase = new File(projectPath, "src/${buildType.toLowerCase()}/jniLibs")
        if (buildFor == 'android') {

            NativeHelper.conanAndroidArchs.each { k, v ->
                File lib = new File(installPathBase, "$k/libctanker.so")
                if (!lib.exists()) {
                    doFirst { getLogger().warn("$lib not found, triggering build") }
                    hasNativeLibs = false
                }
            }
        } else {
            File expectedPath = new File(projectPath, "conan/host/libctanker.so")
            if (!expectedPath.exists()) {
                doFirst { getLogger().warn("$expectedPath not found, triggering build") }
                hasNativeLibs = false
            }
        }
        if (!hasNativeLibs)
            finalizedBy(getProject().getTasks().create("require${buildFor}NativeBuild${buildType}", BuildNative, buildType, buildFor))
    }
}

task buildNativeDebug(type: BuildNative, constructorArgs: ['Debug', 'all'])
task buildNativeHostDebug(type: BuildNative, constructorArgs: ['Debug', 'host'])
task buildNativeRelease(type: BuildNative, constructorArgs: ['Release', 'all'])
task useDeployedNativeDebug(type: UseDeployedNative, constructorArgs: ['Debug'])
task useDeployedNativeRelease(type: UseDeployedNative, constructorArgs: ['Release'])

// Setup regular tasks to depend on Native
tasks.whenTaskAdded { task ->
    if (task.name == 'compileDebugUnitTestKotlin') {
        task.dependsOn tasks.create('requireHostNativeDebug', RequireNativeLibs, 'Debug', 'host')
    } else if (task.name == 'compileReleaseUnitTestKotlin') {
        task.dependsOn tasks.create('requireHostNativeRelease', RequireNativeLibs, 'Release', 'host')
    } else if (task.name == 'bundleDebugAar') {
        task.dependsOn tasks.create('requireAndroidNativeDebug', RequireNativeLibs, 'Debug', 'android')
    } else if (task.name == 'bundleReleaseAar') {
        task.dependsOn tasks.create('requireAndroidNativeRelease', RequireNativeLibs, 'Release', 'android')
    }
}

clean {
    delete "conan/build"
}
