import javax.inject.Inject
import com.sun.jna.Platform

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'javax.inject:javax.inject:1'
        classpath 'net.java.dev.jna:jna-platform:4.5.1'
    }
}

class NativeHelper {
    static def conanAndroidArchs = ["x86_64": "x86_64", "x86": "x86", "armeabi-v7a":"armv7", "arm64-v8a": "armv8"]

    static def runCmd(cmd, path) {
        print("${path}: ${cmd} \n")
        def proc = cmd.execute(null, path)
        proc.consumeProcessOutput(System.out, System.err)
        proc.waitFor()
        if (proc.exitValue() != 0)
            throw new Exception("Command failed: ${cmd}")
    }

    static def getAndroidProfile(arch, buildType) {
        return "android-$arch-${buildType.toLowerCase()}"
    }

    // This creates a .jar with our .so inside, so we can put it in the classpath for tests
    static def createNativeLibJar(ArrayList prefixLibs, File installPath, String jarName) {
        runCmd("jar cf ${jarName} -C ${installPath} ${prefixLibs.join(" ")}", installPath)
    }

    static def copyTankerLibs(File sourceLibPath, ArrayList libNames, File installLibPath) {
        def libFilePaths = libNames.collect { new File(sourceLibPath, System.mapLibraryName(it)) }
        for (libFilePath in libFilePaths) {
          def prefixedLibPath = new File(installLibPath, libFilePath.name)
          prefixedLibPath.parentFile.mkdirs()
          prefixedLibPath.bytes = libFilePath.bytes // This is just a file copy in Groovy
        }
    }

    static def getTankerDepInfos(File conanOutputPath) {
        def conanJsonFile = new File(conanOutputPath, 'conanbuildinfo.json')
        def conanJson = new groovy.json.JsonSlurper().parseText(conanJsonFile.text)
        return conanJson.dependencies.find {it.name == 'tanker' }
    }
}

class Builder extends DefaultTask {
    @InputDirectory
    final File conanPath
    @Internal
    final String buildType
    @OutputDirectories
    final File installPathBaseDebug
    @OutputDirectories
    final File installPathBaseRelease

    Builder(String buildType) {
        def projectPath = new File(getProject().getProjectDir().absolutePath)
        this.conanPath = new File(projectPath, "conan")
        this.buildType = buildType.toLowerCase()
        this.installPathBaseDebug = new File(projectPath, "src/debug/jniLibs")
        this.installPathBaseRelease = new File(projectPath, "src/release/jniLibs")

        // We need to mark the tanker library from the conan cache as Inputs of this task, but
        // the paths are computed in compileForAndroid(). I leave this refactor as an exercise
        // for you. So, for the moment, just re-run this task regardless of whether it is up to
        // date or not. Also, this is not a regression, it's just that since Gradle 7.0 we are
        // forced to mark our task's Inputs and Outputs.
        outputs.upToDateWhen { false }
    }

    void compileForAndroid() {
        // Run each known android arch
        NativeHelper.conanAndroidArchs.each { k, v ->
            def conanOutPath = new File(this.conanPath, NativeHelper.getAndroidProfile(v, this.buildType))
            def tankerDepInfos = NativeHelper.getTankerDepInfos(conanOutPath)
            NativeHelper.copyTankerLibs(new File(tankerDepInfos.lib_paths.first()), tankerDepInfos.libs, new File(this.installPathBaseDebug, k))
            NativeHelper.copyTankerLibs(new File(tankerDepInfos.lib_paths.first()), tankerDepInfos.libs, new File(this.installPathBaseRelease, k))
        }
    }

    void compileForHost() {
        def conanOutputPath = new File(this.conanPath, "linux-${this.buildType}-shared")
        def conanHostPath = new File(this.conanPath, 'host')
        conanHostPath.mkdirs()
        def tankerDepInfos = NativeHelper.getTankerDepInfos(conanOutputPath)
        def libNames = tankerDepInfos.libs
        def platformPrefix = Platform.getNativeLibraryResourcePrefix()
        NativeHelper.copyTankerLibs(new File(tankerDepInfos.lib_paths.first()), libNames, new File(conanHostPath, platformPrefix))
        NativeHelper.createNativeLibJar(libNames.collect { new File(platformPrefix, System.mapLibraryName(it)) }, conanHostPath, 'tanker-native.jar')
    }
}

class BuildNative extends Builder {
    @Internal
    final String buildFor

    @Inject BuildNative(String buildType, String buildFor) {
        super(buildType) 
        this.buildFor = buildFor
    }

    @TaskAction
    void compile() {
        if (buildFor == 'host' || buildFor == 'all')
            this.compileForHost()
        if (buildFor == 'android' || buildFor == 'all')
            this.compileForAndroid()
    }
}

// Note that there are two buildTypes when building this. There's the sdk-native build type, and the
// android apk build variant. I don't know what building a release android apk really means, it's
// probably just about running R8 to minify and tree-shake.
// Anyway, since the android build variant is not that important, all these tasks will build native in
// the requested build type, and copy the resulting libraries for both the debug and release android
// build.
task buildNativeHostDebug(type: BuildNative, constructorArgs: ['Debug', 'host'])
task buildNativeHostRelease(type: BuildNative, constructorArgs: ['Release', 'host'])
task buildNativeAndroidRelease(type: BuildNative, constructorArgs: ['Release', 'android'])
task buildNativeRelease(type: BuildNative, constructorArgs: ['Release', 'all'])

clean {
    delete "conan/build"
}
